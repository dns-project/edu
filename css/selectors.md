Селекторы CSS
=============

## Что хочется узнать

* [@meniam](http://github.com/meniam) Хочу узнать про скорость селекторов
* [@meniam](http://github.com/meniam) Интересна поддержка браузеров, желательно в виде сводной таблицы
* [@trustnik](http://github.com/trustnik) Специфичные селекторы (+, >, ~ и т.д.)

## Что почитать

* http://www.w3schools.com/cssref/css_selectors.asp
* http://everstudent.ru/blog/htmlcss/30-css-seletors-to-memorize/
* http://vvz.nw.ru/Lessons/CSS/selectors.htm
* http://net.tutsplus.com/tutorials/html-css-techniques/the-30-css-selectors-you-must-memorize/
* http://habrahabr.ru/post/150720/


От простого к сложному
## * {margin: 0;}
Данный селектор выделяет все элементы на странице , но очень сильно грузит браузер, поэтому используется редко, хотя иногда его используют чтобы для выделения дочерних элементов #navigation * { border: 1px solid black; } (часто такой способ принимают для нормального отображения в IE6)
## #navigation { border: 1px solid black; }
Селектор выводит элемент с id = 'navigation'(в данном примере), особенности данного селектора в том, что он жестко привязывает стиль к элементу и не дает возможности повторного использования
## .navigation { border: 1px solid black; }
Селектор выводит элемент с class = 'navigation'(в данном примере), основное отличие от id в том что один класс может принаждежать нескольким элементам
## a { text-decoration: none; }
Селектор указывающий тупо на  все тэги а
## li a { text-decoration: none; }
Дочерний селектор, присваивает стиль, если у а есть родительский элемент li
## Псевдо-классы .link:visited и .link:link
Псевдо-класс :link используется для выделения всех ссылок, на которые еще не кликнули
Если же надо применить определенный стиль у уже посещенным ссылкам, то используем псевдо-класс :visited
## p + a { color: red; }
Селектор последующего элемента (в данном примере все ссылки которые идут после тэга p будут отбражаться расным цветом)
## div#container > ul { margin: 5em; }
Дочерний селектор, главное отличие от li a, рассмотренного выше, в том что выбираются непосредственно дочерние элементы
Пример для наглядности:
```
<div id="container">
      
    <ul>(Выберется т.к. родительский элемент непосредственно div#container)
             
        <li> Элемент списка
            <ul>(Не выберется так как родительский элемент li)
                <li> Дочерний элемент</li> 
            </ul>
        </li>
          
        <li> Элемент списка </li>
             
        <li> Элемент списка </li>
             
        <li> Элемент списка </li>
          
    </ul>
   
</div>
```
## p ~ a { color: red; }
Селектор выбирает последующий элемент, отличие от p + a в том, что в p + a выберется только первая ссылка идущая после элемента p, тогда как в p ~ a выберутся все ссылки идущие полсе элемента p
## Использование атрибутов, селектор a[title] { color: green; }
В данном селкторе выбираются все ссылки у которых есть атрибут title
## Использование атрибутов, селектор a[href="http://zapp.ru"] { color: #000000; }
Данный селектор выберет все сслыки которые ссылаются на http://zapp.ru
## Использование атрибутов, селектор a[href*="zapp"] { color: #000000; }
Слектор a[href="http://zapp.ru"] конечно хорош, но что делать если ссылка http://zapp.ru/catalog ? Тут на поможет селектор a[href*="zapp"], селектор выберает все ссылки у которых атрибут href содержит zapp
## Использование атрибутов, селектор a[href^="http"] { color: red; }
Данный селектор выбирает все ссылки у которых значение атрибута href начинается с http
## Использование атрибутов, селектор a[href$=".jpg"] { color: red; }
Селектор смотрит на конец значения атрибута
## Использование атрибутов, селектор a[data-filetype="image"]{ color: red; }
Испульзуется для выборки элементов с заданным нами атрибутом и значением
Пример для наглядности
```
<a href="path/to/image.jpg" data-filetype="image"> Ссылка на изображение </a>
```
## Использование атрибутов, селектор a[data-info~="external"] { color: red; }
Селектор выбирает все элемнты у которых в атрибуте data-info есть значение external, например ссылка
```
<a href="path/to/image.jpg" data-filetype="image external"> Ссылка на изображение </a>
```
станет красной
## input[type=radio]:checked { border:1px solid black; } (Атрибут + псевдо-класс)
Выделяет только элементы пользовательского интерфейса, такие как переключатель или флажок. Причем те, которые отмечены/выбраны.
## Псевдо-классы :before и :after
Генерируют контент вокруг выбранного элемента. Пример:
```
.clearfix:after {
    content: "";
    display: block;
    clear: both;
    visibility: hidden;
    font-size: 0;
    height: 0;
    }
```
*Согласно спецификации CSS3, вы должны использовать два двоеточия (::). Однако, можно использовать и одно двоеточие для совместимости.
## Псевдо-класс div:hover { background: #e3e3e3; }
Применяет стиль когда курсор наведён на элемент
*В старых браузерах :hover применим только к ссылкам
## Псевдо-класс div:not(#container) { color: blue; }
Псевдо-класс "отрицания", данном примере выбирает все div кроме того у которого id="container"
## Псевдо-элементы p::first-line и p::first-letter
p::first-line задёт стиль для первой строки текста элемента p, p::first-letter у первой буквы
## X:nth-child(n)
посволяет выбирать n-ый дочерний элемент, отчет ведётся не с 0, например для выбора второго дочернего элемента li:nth-child(2), можно так же выбрать каждый второй(да-да каждый второй) элемент li:nth-child(2n)
## X:nth-last-child(n)
Индентичен X:nth-child(n), единственное отличе в том что отсчет ведётся с конца
## X:nth-of-type(n)
Селекторы выше выбирали дочерние элементы(т.е определённый li у ul), а что если нам надо выбрать определённый тип элемента, у которого нет уникального id, есть такое решение: ul:nth-of-type(3) { border: 1px solid black; }, в примере 3-ий ul обводится рамкой
## X:nth-last-of-type(n) 
Тоже самое что и предыдущий пример, только считывает элементы с конца
## X:first-child и X:last-child
Выбирает первый и последний элемент соответственно
## X:only-child
Выбирает только первый дочерний элемент, пример для стиля div p:only-child { color: red; }: 
```
<div>
    <p> Один параграф.</p> (будет красным)
</div>
<div>
    <p> Два параграфа </p> (не будет красным)
    <p> Два параграфа </p>
</div>
```
## X:only-of-type
Выбирает только тот элемент который не имеет соседей в пределах родительского элемента. Пример: такой вот стиль li:only-of-type { font-weight: bold; } применим только для:
```
<ul> 
     <li> Пункт меню </li> 
</ul>
```
## X:first-of-type
Выбирает первый элемент заданного типа

# Совместимости
<table border=1 cellpadding=0 cellspacing=0>
<tr> 
<td>Селектор</td><td>IE(версия)</td><td>Firefox</td><td>Chrome</td><td>Safari</td><td>Opera</td>
</tr>
<tr> 
<td>*</td><td>IE6 +</td><td>+</td><td>+</td><td>+</td><td>+</td>
</tr>
<tr> 
<td>#X</td><td>IE6 +</td><td>+</td><td>+</td><td>+</td><td>+</td>
</tr>
<tr> 
<td>.X</td><td>IE6 +</td><td>+</td><td>+</td><td>+</td><td>+</td>
</tr>
<tr> 
<td>X</td><td>IE6 +</td><td>+</td><td>+</td><td>+</td><td>+</td>
</tr>
<tr> 
<td>Х Y</td><td>IE6 +</td><td>+</td><td>+</td><td>+</td><td>+</td>
</tr>
<tr> 
<td>X:visited и X:link</td><td>IE7 +</td><td>+</td><td>+</td><td>+</td><td>+</td>
</tr>
<tr> 
<td>Х+Y</td><td>IE7 +</td><td>+</td><td>+</td><td>+</td><td>+</td>
</tr>
<tr> 
<td>Х>Y</td><td>IE7 +</td><td>+</td><td>+</td><td>+</td><td>+</td>
</tr>
<tr> 
<td>Х ~ Y</td><td>IE7 +</td><td>+</td><td>+</td><td>+</td><td>+</td>
</tr>
<tr> 
<td>X[title]</td><td>IE7 +</td><td>+</td><td>+</td><td>+</td><td>+</td>
</tr>
<tr> 
<td>X [href="Foo"]</td><td>IE7 +</td><td>+</td><td>+</td><td>+</td><td>+</td>
</tr>
<tr> 
<td>X [href *= "everstudent.ru"]</td><td>IE7 +</td><td>+</td><td>+</td><td>+</td><td>+</td>
</tr>
<tr> 
<td>X[href^="http"]</td><td>IE7 +</td><td>+</td><td>+</td><td>+</td><td>+</td>
</tr>
<tr> 
<td>X[href$=". JPG"]</td><td>IE7 +</td><td>+</td><td>+</td><td>+</td><td>+</td>
</tr>
<tr> 
<td>X[data-*="foo"]</td><td>IE7 +</td><td>+</td><td>+</td><td>+</td><td>+</td>
</tr>
<tr> 
<td>X[foo~="bar"]</td><td>IE7 +</td><td>+</td><td>+</td><td>+</td><td>+</td>
</tr>
<tr> 
<td>X:checked</td><td>IE9 +</td><td>+</td><td>+</td><td>+</td><td>+</td>
</tr>
<tr> 
<td>:before и :after</td><td>IE8 +</td><td>+</td><td>+</td><td>+</td><td>+</td>
</tr>
<tr> 
<td>X:hover</td><td>IE6 + (В IE6: hover должен быть применен к ссылке)</td><td>+</td><td>+</td><td>+</td><td>+</td>
</tr>
<tr> 
<td>X:not(selector)</td><td>IE9 +</td><td>+</td><td>+</td><td>+</td><td>+</td>
</tr>
<tr> 
<td>X::first-line и X::first-letter</td><td>IE6 +</td><td>+</td><td>+</td><td>+</td><td>+</td>
</tr>
<tr> 
<td>X:nth-child(n)</td><td>IE9 +</td><td>Firefox 3,5 +</td><td>+</td><td>+</td><td>+</td>
</tr>
<tr> 
<td>X:nth-last-child(n)</td><td>IE9 +</td><td>Firefox 3,5 +</td><td>+</td><td>+</td><td>+</td>
</tr>
<tr> 
<td>X:nth-of-type(n)</td><td>IE9 +</td><td>Firefox 3,5 +</td><td>+</td><td>+</td><td>+</td>
</tr>
<tr> 
<td>X:nth-last-of-type(n)</td><td>IE9 +</td><td>Firefox 3,5 +</td><td>+</td><td>+</td><td>+</td>
</tr>
<tr> 
<td>X:first-child</td><td>IE7 +</td><td>+</td><td>+</td><td>+</td><td>+</td>
</tr>
<tr> 
<td>X:last-child</td><td>IE9 +</td><td>+</td><td>+</td><td>+</td><td>+</td>
</tr>
<tr> 
<td>X:only-child</td><td>IE9 +</td><td>+</td><td>+</td><td>+</td><td>+</td>
</tr>
<tr> 
<td>X:only-of-type</td><td>IE9 +</td><td>Firefox 3,5 +</td><td>+</td><td>+</td><td>+</td>
</tr>
<tr> 
<td>X:first-of-type</td><td>IE9 +</td><td>Firefox 3,5 +</td><td>+</td><td>+</td><td>+</td>
</tr>
</table>

# Немного о скорости селекторов
Для каждого текущего обрабатываемого элемента HTML-разметки браузер последовательно проверяет применимость всех относящихся к данному HTML-документу CSS-правил, разбирая селекторы в направлении справа налево. Рассмотрим для определенности пример:
```
.content ul li {…}
```
Встречая CSS-правило, начинающееся таким селектором, браузер сперва проверяет, является ли текущий обрабатываемый элемент пунктом списка (li).
Если ответ — «нет», обработка данного CSS-правила завершается. Разумеется, оно не применяется к текущему элементу. Браузер переходит к обработке следующего CSS-правила (или же следующего элемента HTML-разметки, если для текущего элемента проверена применимость всех имеющихся правил, то есть данное правило было последним в очереди).
Если же ответ — «да», браузер следует вверх по DOM-дереву в поисках элемента ul с целью проверить, является ли наш пункт списка (li) потомком какого-либо неупорядоченного списка (ul).
Дальше события развиваются аналогичным образом. Если упомянутое условие вложенности элементов выполняется, браузер следует еще выше по дереву DOM, проверяя, является ли этот список (ul) потомком некоего элемента с классом content.
полне очевидно, что наиболее предпочтительным с точки зрения производительности является использование селекторов, требующих минимального количества проверок, причем проверок самых простых, в первую очередь под это описание подходят простые селекторы по элементу, по идентификатору и по классу, еще больше ресурсов отнимет обработка CSS-правила с селектором по атрибуту, соответсвенно по значению атрибута будет отниаться ещё больше времени, также крайне «медленным» будет простой селектор, использующий динамический псевдокласс :hover (т.к. будет осуществляться проверка, не наведен ли на него курсор мышки), излишнее уточнение тоже вредно(нет надобности вместо #header писать div#header).
Из комбинированных селекторов самый быстрый явдяется 
```
          h1 + p {…}
```
В данном случае для каждого элемента p требуется произвести одну сравнительно несложную проверку — предшествует ли ему непосредственно элемент h1, селектор типа: 
``` 
  ul > li {…}
```
будет чуть медленее, также при использовании комбинированных селекторов необходимо всячески воздерживаться от соблазна использовать более одного комбинатора на каждый такой селектор.
