## Зачем они нужны?

Когда писать SQL руками надоедает начинается поиск решения, которое призвано облегчить жизнь. Я долго искал такое решение и... не нашел. Есть много хороших фреймворков, которые облегчают работу с простыми данными. Но, как только дело доходит до сложных запросов или оптимизайций - они сливаются, либо делают пол Пэ.

## Что такое модели?
Модели это вам не ORM, они не делают абстракции от базы данных и в контроллерах все равно будет говнокод, точнее условия для SQL. Модельки - это небольшая обертка над PDO, которая позволяет делать повседневные действия очень просто. Так же может запросто управляться со сложными запросами, ибо моделям похеру откуда и как беруться данные :)

## А чем модели лучше чем Doctrine, Yii и прочее
Да ничем, юзайте Doctrine 2


##Как создать модели?
Модели генерируются на основе вашей базы данных. Есть специальный генератор на php, которому вы указывается путь до бд, логин,пароль и т.п. Генератор при запуске лезет в вашу бд просит ее схему и на основе схемы генерит модели. Все просто. Для того,чтобы модели генерились правильно необходимо делать правильную структуру бд. Об этом можно почитать в нотации по mysql. Если ее соблюдать, то будет генериться куча всего полезного.
Про то как запускать генератор можно почитать  здесь https://github.com/esteit/model/blob/master/README.md

##Что генерится?
Для каждой таблицы (за исключением таблиц связок для типа связи "Многие-ко-многим") генерятся следующий классы - Model, ModelAbstract, Entity, EntityAbstract, Collection, CollectionAbstract.

##Для чего нужно?
Рассматривать будем на примере урезанного интернет-магазина. Допустим у нас есть таблицы -
- product - таблица продуктов,
- product_info - описание каждого продукта вынесено в отдельную таблицу, связь один-к-одному
- product_image - картиночки продуктов, связь один-ко-многим
- rubric - рубрики нашего магазина,
- product_rubric_link - связь многие-ко-многим наших рубрик с товарами.

Примерные sql-нички для создания этих табличек с проставлленными индексами, связями и триггерами можно глянуть здесь 
https://github.com/esteit/edu/blob/master/models/test_db.sql
      
Генерим модельки. 

Для каждой таблицы, кроме таблиы связок product_rubric_link получаем следующие файлы

%table_name%Model,
%table_name%ModelAbstract,
%table_name%Entity, 
%table_name%EntityAbstract,
%table_name%Collection, 
%table_name%CollectionAbstract

<ВАЖНО!>
"Почему всего по два? "- спросите вы, имея ввиду обычный класс унаследованный от абстрактного и собственно, абстрактный. Потому что  **все методы, которые генерятся автоматически находятся в АБСТРАКТНЫХ КЛАССАХ. Соответсвенно, когда вы поправите структуру базы и перегенерите модели, то абстрактные классы перетрутся! ** Поэтому  **всю логику и собственные методы нужно писать в обычных (не абстрактных классах) оне не перетераются при перегенеривании **. 
</ВАЖНО!>

Для таблицы product у нас сгенерились следующие классы
ProductModel, ProductModelAbstract, ProductEntity, ProductEntityAbstract,  ProductCollection, ,  ProductCollectionAbstract

Теперь опишем что зачем нужно.

Класс ProductModelAbstract -  содержит кучу сгенеренных выборок из таблицы продуктов: getProduct, getProductByProduct, getProductList, getProductListByProduct, getProductListByRubric, getProductByProductInfo и еще кучу всего. Это сгенеренные выборки для получения одного продукта или списка (коллекции) продуктов. Причем обратите внимание что генерятся и методы для получения продукта по связанным сущностям - по инфо, по рубрике и т.д.
Также содержит методы 
addProduct для добавления продукта.
updateProduct для изменения продукта.
importProduct - специальный метод, который умеет проверять есть ли уже такой продукт. Если есть, то метод проапдейтит запись, если нет,то добавит.



- Класс ProductModel - наследуется от ProductModelAbstract, пустой класс, предназначен для собственных методов - выборки, бизнес логики и т.д.
- Класс ProductEntityAbstract - класс объект которого содержит одну выбранную сущность. Т.е. когда мы вызываем  ProductModel::getInstance()->getProductByProduct(23) то модель вернет нам ProductEntity, которая будет содержать данные по продукту с id 23.  **Entity предназначена только для хранения данных. ** Этот объект неизменяем, не умеет себя сохранять или доставать заново из базы и т.д. Только хранит данные по записи и может их вам вернуть в том или ином виде. Например вызвав автоматически сгенерированные методы $product->getName()  и $product->getPrice() можно получить название и цену продукта.
- Класс ProductEntity - наследуется от ProductEntityAbstract, пустой класс, предназначен для собственных методов.
- Класс ProductCollectionAbstract -  предназачен для хранения набора Entity.  Т.е. когда мы получаем список продуктов, например с помощью метода ProductModel::getInstance()->getProductList(), то мы получим ProductCollection, которая содержит в себе какое-то количество ProductEntity. Наследуется от Model_Collection_Abstract, которая содержит полезные методы - например getIdsAsArray, _preparePlainTreeArray и _prepareNestedTreeArray для представления коллекции в виде плоского или вложенного дерева и другие. **Коллекция также как и entity НЕИЗМЕННА. Предназначена только для хранения данных.** Колеекция наследуется от array_iterator  и ее можно итерировать как обычный массив.
- Класс ProductCollection - наследуется от ProductCollectionAbstract, пустой класс, предназначен для собственных методов.

###Подведем промежуточные итоги и выпишем концепции

В моделях три основные запасные части, с которыми прийдется работать ежедневно:

- Entity - единица/элемент (элемент чего-то, например, продукт)
- Collection - набор элементов, содержит в себе массив entity.
- Model - собственно сама модель отношений (менеджер позволяющий производить выборки, вставки и т.п. и действия с Entity и Collection)

Каждая сущность представлена в 2х экземплярах - абстрактный и обычный класс. Абстрактный автоматически генерируется и перетирается при каждой генерации моделей. Поэтому в них ниче дописыват нельзя. И обычный, унаследованный от абстрактного класса, для того чтобы писать туда свои методы и бизнес логику. 

####Политика партии

- Entity неизменна, то есть создав этот объект, нельзя изменить его значения. Если очень надо, то создавайте новый.
- Entity не может сохранить себя, выбрать другую Enity или еще раз себя, она не знает кто ее коллекция и не знает кто ее менеджер. Она тупо хранит данные и предосталяет методы для их получения. Сеттеров у Entity нет.
- Для коллекции те же правила, что и для Entity. Просто хранилище набора Entity. Коллекция знает какие Entity внутри, но не знает кто ее менеджер.
- Model - царь и бог, умеет делать выборки, вставки и другие запросы, управлять entity, collection, хранит бизнес логику, починяет примус.