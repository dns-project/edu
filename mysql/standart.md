# Стандарт MySQL
## Введение
В данной нотации изложены основные требования, которые предъявляются к именованию и описанию различных компонентов баз данных, таких как таблицы, поля и другие. Нотация является необходимой. Это обусловлено тем, что если каждый компонент базы данных имеет название в соответствии с определенными стандартами именования, то это обеспечивает четкость ее структуры. При этом логика базы данных становится ясной для человека, который знает стандарты именования, но не знаком с ее структурой. Поэтому будущим разработчикам не придется тратить время на выяснение того, что значит та или иная таблица или поле.
## Типы таблиц
### Таблица сущности
**Таблица сущности** - это таблица с данными, описывающим одну сущность. Но при необходимости из нее может быть вынесена группа полей в отдельные таблицы с постфиксами '_info' и '_stat', которые описанны далее. При именовании таблицы сущности используются следующие правила:
* имя таблицы составляется из английского слова, слов или их аббревиатур в нижнем регистре, соответствующих понятию, которое однозначно характеризует эту сущность. Например, таблица для сущности 'Заказ' может иметь название 'order';
* если имя таблицы состоит из нескольких слов, то не допускается использовать пробел, слова должны быть разделены символом '_';
* если сущность является привязанной к какой-либо другой, то имя таблицы будет формироваться следующим образом:

<pre> 'name1_name2',
где   name1 - имя таблицы к которой привязана сущность,
name2 - имя таблицы сущности. 
</pre>
     
Например, таблица для сущности 'Товары, входящие в заказ' будет иметь имя 'order_product';

* имя таблицы не должно совпадать с ключевыми словами SQL или СУБД;
* в именах таблиц не допускается использование множественного числа слов, например, products или brands. Вместо них следует использовать слова в единственном числе, например, product и brand. В этом случае исключается ошибка неправильного образования множественного числа слова и нарушения его смысла, это не высосанное из пальца правило, давайте сравним: "SELECT brands.id FROM brands WHERE brands.id = 1" VS. "SELECT brand.id FROM brand WHERE brand.id = 1" (если перевести на русский, то получится в первом случае "ВЫБЕРИ ИД брендов" во втором "ВЫБЕРИ ИД бренда")

### Поочередность слов в названии сущности
Если сущность является зависимой от другой сущности, то очередность слов в названии таблицы сущности будет такая: сначала имя таблицы сущности, от которой зависит сущность и только потом название описываемой сущности в соответствии с вышеизложенными правилами. Например, есть таблицы 'product_color' и 'color'. Эти таблицы описывают разные сущности 'Цвет продукта' и 'Цвет' соответственно. В тоже время, 'Цвет' - это более общее понятие, а 'Цвет продукта' - более частное.

Для таблиц связи (см. раздел Таблица связи сущностей) похожая ситуация. Очередность имен таблиц в имени таблицы связи строится на основе логического смысла. При этом то, с чем связывается ставится сначала, а что связывается - в конце. Например, связываем сущность 'Тэг' с сущностью 'Товар', тогда имя таблицы будет 'product_tag_link', если же наоборот - тогда таблица будет иметь имя 'tag_product_link'.

**Игровая задача №1**

У нас есть товары, к каждому товару привязаны цвета товара, так же к товару привязаны размеры товара, при этом есть прямая зависимость наличия определенного размера у определенного размера конкретного товара (во как загнул). Человеческим языков, есть товар "Майка" у него есть два цвета "Белый" и "Черный". У нас можно купить Белую майку с размерами XXL, XL, а черную только с размерами XL и S. Как сформировать названия таблиц?

### Разбивка сущности на разные таблицы

**Информация о сущности (_info таблицы)**

Если одно или несколько полей таблицы сущности содержат данные, которые представлены большими объемами текстовой информации и занимают большое количество памяти, то эти поля выносятся в отдельную таблицу с именем:

<pre> 'name_info', 
 где name - имя таблицы сущности. </pre>
 
Например, поле 'descr' в таблице 'product', имеющее тип данных TEXT, должно быть вынесено в таблицу 'product_info'. Это связано с ростом затрат памяти при росте объемов выборки записей из таблицы сущности 'product'.

**Статистические данные сущности (_stat таблицы)**

К статистическим данным относится, например, информация о том сколько изображений соответствует одному товару из таблицы 'product' или сколько вариантов цветов имеет товар. Эти статистические данные должны быть вынесены в отдельную таблицу с именем:

<pre>     'name_stat', 
 где name - имя таблицы сущности. </pre>

Это обусловлено тем, что статистические данные могут обновляться в единицу времени большое количество раз и при каждом обновлении происходит блокировка таблицы сущности и сбивается кэширование выполняемых запросов. Все это отрицательно сказывается на производительности базы данных.

### Таблица связи сущностей

**Таблица связи сущностей** - таблица, которая предназначена для организации связи многие-ко-многим между сущностями. Название такой таблицы будет формироваться следующим образом:

<pre> 'name1_name2_..._nameN_link', 
 где name1 - имя первой таблицы сущности,
     name2 - имя второй таблицы сущности,
     nameN - имя n-ой таблицы сущности. </pre>

Например, имя таблицы для связи сущности 'Товары' (таблица 'product') и 'Тэги' (таблица 'tag') будет иметь вид: 'product_tag_link'.

## Правила именования полей

Основные правила именования полей можно сформулировать следующим образом:

* имя поля составляется из английского слова, слов или их аббревиатур в нижнем регистре, соответствующих понятию, которое однозначно характеризует информацию, которая содержится в этом поле;
* если имя состоит из нескольких слов, то каждое слово должно быть разделено символом '_'.
* поля разных таблиц с одинаковым назначением именуются одинаково во всех таблицах. Например, поле 'name', которое описывает название или поле 'descr', которое используется для описания.

Далее описаны правила именования для конкретных типов полей.

### Поля идентификаторов

**Идентификатор** - поле или группа полей таблицы базы данных, значение которого (или комбинация значений которых) используется в качестве уникального ключа для однозначного определения записи таблицы. Поля идентификаторов могут использоваться в качестве первичного (PRIMARY KEY) и внешнего (FOREIGN KEY) ключей. Для них правила именования в пределах одной таблицы будут следующими:
* для поля, которое является первичным ключом, должно быть использовано имя 'id'.
* для полей, которые являются вторичным ключом, используется следующая схема именования:
* 
<pre>     'name_id',
 где name - имя связанной таблицы. </pre>

Например, поле 'brand_id' для таблицы 'product' будет являться вторичным ключом таблицы 'brand'. Тип поля: INT(11) UNSIGNED.

### Поля даты

Имя полей даты должно формироваться следующим образом:

<pre>     'name_date',
 где name - название поля. </pre>
 
Поля даты должны быть в формате timestamp, каждая сущность должна иметь как минимум два поля с датой: create_date и modify_date.

Эти поля нужны для отладки и исправления косяков. Например, у нас что-то сломалось и пошли не правильные данные, мы можем выбрать их по дате создания. Мы написали неправильный SQL и загубили 100 строк, можем найти их по дате изменения.

Отдельного внимания заслуживает modify_date. Что бы не следить за его изменением, мы используем следующую конструкцию: modify_date Значение по умолчанию CURRENT_TIMESTAMP on update CURRENT_TIMESTAMP

То есть поле обновляется автоматически!

**Примеры полей даты**

**create_date** - дата создания

**modify_date** - дата изменения 

**delete_date** - дата удаления

**check_date** - дата проверки

**download_date** - дата загрузки, например, изображения

**run_date** - дата запуска, например, планировщика

**birth_date** - дата рождения, например, пользователя

**start_date** - дата начала

**end_date** - дата конца

**image_count_date** - так например делаем дату, когда обновили количество картинок

### Поля статусов

**Поле статуса** - поле, заданное как перечисление ENUM и содержащее различные состояния сущности. Поле статуса должно иметь одинаковое имя 'status' во всех таблицах базы данных. Также с этим полем могут быть связные поля, так же заданные как перечисления, которые поясняют причину того или иного состояния поля 'status'. Имя этого поля формируется следующим образом:

<pre>     'status_reason', 
 где status - одно из значений статуса,  которое поясняется. </pre>

Например, поле 'status' в таблице 'product' имеет тип ENUM('active','inactive') и отражает различные состояния товара. Для него есть поле 'inactive_reason' ENUM('unknown','hand','not_in_stock','brand','shop','price','image','timeout'), которое уточняет причину статуса 'inactive'.

**Перечень стандартных статусов**

**pending** - ожидает обработки
**active** - активен, можно с ним работать
**inactive** - отключен
**При этом причинами статуса (active_reason или inactive_reason) будут следующие:**
**deleted** - удален, типа как в корзине, как правило если есть такой статус должно быть поле delete_date (дата удаления)
**not_paid** - не оплачен, например, заказ
**moderating** - находится на модерации
**convert** - обработано, например, изображение
**new** - новая, например, корзина
**buy** - оплачивается
**packaged** - упакованный
**problem** - есть какая-то проблема
**bought** - купленный, например, товар
**not_bought** - не купленный

### Поля флагов

**Флаг** - поле, которое может иметь два значения: истина и ложь. Это поле должно иметь тип ENUM со значениями 'y' (соответсвует значению 'истина') и 'n' (значению 'ложь'), в MySQL это будет выглядеть так ENUM('n', 'y') - обратите внимание, что 'n' идет первым Для данного поля используется следующее имя:

<pre>     'is_flag', 
 где flag - имя флага. </pre>

Например, для флага 'paid' имя поля будет 'is_paid'.

###Принципиальное отличие флага от статуса

Статус отличается от флага тем, что у статуса может быть множество значений, в то время, как у флага только два значения: истина и ложь. В то же время статус - это более общее понятие, которое как бы объединяет в себе множество логически связанных флагов. Поэтому, для того, чтобы не создавать бесчисленное множество флагов типа: 'is_active', 'is_deleted', 'is_paid' и т.д. для одной сущности, их объединяют в одно поле 'status'.

###META поля

**META-поля** - это поля для хранения метаданных для записи таблицы. К данным полям относятся следующие:

* meta_title - для хранения заголовков;
* meta_description - для хранения краткого описания данных;
* meta_keywords - для хранения ключевых слов.

Тип поля: VARCHAR(255).

### Поля имени

Название поля: 'name' Тип поля: VARCHAR(255).

###Поля описания

Название поля: 'description' Тип поля: TEXT или LONGTEXT.

###Поля с ценой

Название поля: 'price'. Если поле должно быть описано группой слов для уточнения, то в названии должен быть префикс 'price_'. Например, 'price_min' и 'price_max', которые предназначены для минимальной и максимальной цены соответсвенно. Тип поля должен быть FLOAT(9,2) UNSIGNED. Это обусловлено тем, что цена не может быть отрицательна, но может иметь дробную часть, для описания которой достаточно двух значимых знаков.

###Stem-поля (_stem)

**Стемминг** — это процесс нахождения основы слова для заданного исходного слова. Основа слова необязательно будет совпадать с морфологическим корнем слова. Процесс стеминга применяется в поисковых системах для обобщения поискового запроса пользователя. Конкретные реализации стемминга называются алгоритм стемминга или просто стеммер. Stem-поле - поле, которое хранит основы слов из поля, с которым оно связано, полученные в результате работы стеммера. При этом имя stem-поля формируются следующим образом:

<pre>     'parent_stem',
 где parent - название поля, от которого образовано stem-поле. </pre>

Например, в таблице 'tag' есть поля 'name' и связанное с ним поле 'name_stam', которое используется для хранения основ слов, при этом слова отсортированы в алфавитном порядке.

###Хеш-поля (_hash)

**Хэш-поле** - поле, которое хранит хэш, полученный путем шифрования значения поля, с которым оно связано. Имя данного поля формируется следующим образом:

<pre>     'parent_hash',
 где parent - название поля, от которого образовано хэш-поле. </pre>

Тип поля: VARCHAR(40). Хэш-поле может быть использовано в следующих случаях:
* для обеспечения хранения в базе только уникальных записей. Достигается путем задания для хэш-поля ограничения UNIQUE;
* в качестве заменителя индексу для полей с типом VARCHAR для поиска.

###Fid-поля

**Fid-поле (foreign id поле)** - поле, которое хранит id данных, полученных из внешнего источника.Имя данного поля формируется следующим образом:

<pre>     'name_fid',
 где name - название таблицы сущности. </pre>
 
##Индексы

###Простые индексы

###Уникальные ключи

##Уникальные ключи на текстовые поля

###Внешние ключи

###Составные индексы

##Правило написание SQL-запроса, что бы не было косяков с составными индексами?

##Триггеры

**Триггер** — это хранимая процедура, которая не вызывается непосредственно, а исполняется при наступлении определенного события (вставка, удаление, обновление строки). Триггеры применяются для обеспечения целостности данных и реализации сложной бизнес-логики. Триггер запускается сервером автоматически при попытке изменения данных в таблице, с которой он связан. Синтаксис создания триггера:
<pre>     CREATE TRIGGER trigger_name trigger_time trigger_event ON tbl_name 
     FOR EACH ROW trigger_stmt
 где trigger_name — название триггера, оно должно быть уникальным в пределах базы данных и отражать назначение триггера, формируется следующим образом:
           'trg_event_table',
     где event - сокращенное название события, например bi - BEFORE UNSERT или au - AFTER UPDATE,
         table - имя таблицы, с которой связан триггер.
     trigger_time — время срабатывания триггера. BEFORE — перед событием. AFTER — после события.
     trigger_event — событие:
         insert — событие возбуждается операторами insert, data load, replace
         update — событие возбуждается оператором update
         delete — событие возбуждается операторами delete, replace. Операторы DROP TABLE и TRUNCATE не активируют выполнение триггера
     tbl_name — название таблицы, с которой триггер связан.
     trigger_stmt выражение, которое выполняется при активации триггера. </pre>

**Пример**

<pre> Есть таблица статистики для товара 'product_stat', у нее есть поле 'image_count', в которое помещается количество картинок из таблицы 'product_image', соответствующих товару с id равным 'product_id'. Таким образом, триггер для пересчета значения поля 'image_count' при добавлении новой картинки будет следующим:
     CREATE TRIGGER trg_ai_product_image AFTER INSERT ON product_image
     FOR EACH ROW BEGIN
         SET @imageCount = (SELECT COUNT(*) FROM product_image WHERE product_id = NEW.product_id AND status = 'active');
         IF @imageCount IS NULL THEN
             INSERT INTO product_info SET product_id = NEW.product_id, image_count = 0
                 ON DUPLICATE KEY UPDATE image_count = 0;
         ELSE
             INSERT INTO product_info SET product_id = NEW.product_id, image_count = @imageCount
                 ON DUPLICATE KEY UPDATE image_count = @imageCount;
         END IF;
     END </pre>

Однако такой триггер может отрицательно повлиять на производительность БД, когда в базу будет одновременно добавляться большое количество товаров и изображений. Поэтому использовать такого рода триггеры не желательно, лучше пересчет осуществлять программно.

Более подробную информацию о триггерах можно получить из официальной документации MySQL http://dev.mysql.com/doc/refman/5.0/en/create-trigger.html http://dev.mysql.com/doc/refman/5.0/en/create-trigger.html

##FAQ

###Можно ли наложить индексы на все и радоваться жизни?













